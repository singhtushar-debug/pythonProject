from fastapi import FastAPI, Depends, Request, HTTPException

# from fastapi.responses import JSONResponse
from fastapi.security import OAuth2PasswordRequestForm
from contextlib import asynccontextmanager
from models import Product
from sqlalchemy.ext.asyncio import AsyncSession
from services.product_service import ProductService
from logger_setup import init_logger

# from dotenv import load_dotenv
from db import get_db, engine
from auth import create_token, get_user

# import os
import database_models
import uvicorn
# import jwt

# load_dotenv()
# JWT_SECRET = os.getenv("JWT_SECRET")
# ALGORITHM = os.getenv("ALGORITHM")

# security = HTTPBearer()

logger = init_logger()


# create tables
@asynccontextmanager
async def lifeSpan(app: FastAPI):
    async with engine.begin() as connection:
        await connection.run_sync(database_models.Base.metadata.create_all)
    yield


app = FastAPI(lifespan=lifeSpan)

product_service = ProductService()


# @app.middleware("http")
# async def auth_middleware(request: Request, call_next):
#     """
#     Middleware to handle JWT authentication.

#     This middleware intercepts incoming HTTP requests to validate a Bearer token provided in the 'Authorization' header.

#     Args:
#         request: The incoming request object.
#         call_next: The function that passes the request to the next middleware or path operation.
#     Returns:
#         Response: The final processed response if authentication is successful.
#         JSONResponse: A 401 Unauthorized access response if authentication fails.

#     How it works:
#         1.Check if the path is in the public_paths list.
#         2.Validates the presence and format of the 'Bearer' token.
#         3.Decodes the JWT using the secret key and algorithm.
#         4.Return the response.
#     """
#     public_paths = ["/", "/docs", "/login", "/openapi.json"]
#     if request.url.path in public_paths:
#         return await call_next(request)
#     auth_header = request.headers.get("Authorization")
#     if not auth_header or not auth_header.startswith("Bearer"):
#         return JSONResponse(
#             status_code=401,
#             content={
#                 "detail": "Missing or invalid authentication token. Please login !"
#             },
#         )
#     token = auth_header.split(" ")[1]
#     try:
#         data = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
#         request.state.user = data
#     except jwt.ExpiredSignatureError:
#         return JSONResponse(
#             status_code=401, content={"detail": "Token is expired,login again"}
#         )
#     except jwt.InvalidTokenError:
#         return JSONResponse(status_code=401, content={"detail": "Invalid token"})
#     response = await call_next(request)
#     return response


@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    """
    HTTP Middleware: Intercepts and logs details of every incoming request and its corresponding response code.

    Args:
        request(Request): The incoming FastAPI request object.
        call_next: The next handler in the middleware chain.
    Returns:
        Response: The final response generated by the application.
    """
    response = await call_next(request)
    logger.info(f"{request.method} {request.url.path} | Status: {response.status_code}")
    return response


# home page
@app.get("/")
async def welcome_home():
    return "Welcome to the home page"


@app.post("/login")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Function to simulate a user login.

    Returns:
        access_token: A jwt token.
    """
    if form_data.username != "Tushar" or form_data.password != "password":
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    token = create_token(data={"username": form_data.username})
    return {"access_token": token}


# get all product
@app.get("/products")
async def get_all_products(
    current_user: dict = Depends(get_user), db: AsyncSession = Depends(get_db)
):
    """
    Fetches the complete list of products.

    Returns:
        List[Products]: A list containing all product records.
    """

    return await product_service.get_all_products(db)


# get product by id
@app.get("/product/{id}")
async def get_product_by_id(
    id: int, current_user: dict = Depends(get_user), db: AsyncSession = Depends(get_db)
):
    """
    Fetches a product using its unique id.

    Args:
        id: The unique integer id of the product.

    Returns:
        Product: The matching product object if found,otherwrise returns NULL.
    """
    return await product_service.get_product_by_id(id, db)


# add a new product
@app.post("/add-product")
async def add_product(
    product: Product,
    current_user: dict = Depends(get_user),
    db: AsyncSession = Depends(get_db),
):
    """
    Add a new product to the product list.

    Args:
        Product: The product to be added.

    Returns:
         Product: The product to be added.
    """
    return await product_service.add_product(product, db)


@app.put("/product")
async def update_product(
    id: int,
    product: Product,
    current_user: dict = Depends(get_user),
    db: AsyncSession = Depends(get_db),
):
    """
    Updates an existing product record.

    Args:
        id: The id of the product to be updated.
        Product: The updated product.

    Returns:
        Product: The updated prodcut if successfull,otherwise returns NULL.

    """
    return await product_service.update_product(id, product, db)


@app.delete("/product/{id}")
async def delete_product_by_id(
    id: int, current_user: dict = Depends(get_user), db: AsyncSession = Depends(get_db)
):
    """
    Removes a product record from the inventory.

    Args:
        id: The id of the product to be deleted.

    Returns:
        Product: The removed product if successfull, otherwise None.
    """
    return await product_service.delete_product(id, db)


def main():
    # print("Hello from pythonproject!")
    uvicorn.run(app, host="127.0.0.1", port=8000)


if __name__ == "__main__":
    main()
